# Sampling frame {#sec-sampling-frame}

```{r loadAreaEcoz,echo=FALSE,message=FALSE,warning=FALSE}
suppressPackageStartupMessages(library(sf))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(kableExtra))
suppressPackageStartupMessages(library(ggspatial))

area = readRDS(file.path('..', 'data', 'area.RDS'))
ecoz = read_sf(file.path('data', 'Ecozones', 'ecozones.shp')) |>
    st_transform(st_crs(area)) |>
    st_intersection(area) |>
    mutate(Ecozone = ZONE_NAME) |>
    select(Ecozone)
prov = readRDS(file.path('data', 'province.RDS'))
ecor = readRDS(file.path('..', 'data', 'districts.RDS'))
hexas = readRDS(file.path('..', 'data', 'hexa_complete.RDS'))
```

## Area of study

The study area for Quebec is outlined in @fig-study-area.
It was expanded beyond the Boreal boundary to include the Arctic ecosystems.
The study area contains a total of 7 ecozones, and their sizes and proportions are described in @tbl-ecozone:

```{r tableEcoz,echo=FALSE,message=FALSE,warning=FALSE}
#| label: tbl-ecozone
#| tbl-cap: "Area (in hectares) and proportion of ecozones covered by the study area."

eco_name = unique(ecoz$Ecozone)
eco_size = st_area(ecoz)
# merge same ecozone splited in two polygons
eco_size = c(eco_size[1:6], sum(eco_size[7:8]))
units(eco_size) = NULL
tibble(
    Ecozone = eco_name,
    Siz = eco_size
) |>
arrange(desc(Siz)) |>
mutate(
    `Area (% prop)` = paste0(
        round(Siz/10000, 0),
        ' (',
        round(Siz/sum(Siz) * 100, 2),
        ')'
    )
) |>
select(-Siz) |>
    kbl(format = 'markdown', align = 'c')
```

```{r printStudyArea,echo=FALSE,message=FALSE,warning=FALSE,fig.width=7.5,fig.height=7.5}
#| label: fig-study-area
#| fig-cap: "Study area (colored polygons) and its ecozone. The ecozone map was extracted from the Terrestrial Ecoregions of Canada data product - Government of Canada; Agriculture and Agri-Food Canada."

prov |>
    ggplot() +
        geom_sf() +
        geom_sf(data = area, fill = 'gray') +
        geom_sf(data = ecoz, aes(fill = Ecozone), alpha = .5) +
        geom_sf_label(
            data = ecoz[-nrow(ecoz), ],
            aes(label = Ecozone),
            nudge_y = -.3,
            label.size = 0.1
        ) +
        coord_sf(crs = 4326) +
        annotation_north_arrow(
            location = 'br',
            which_north = 'true'
        ) +
        theme_minimal() +
        theme(legend.position = 'none') +
        xlab('') + ylab('')
```

In order to accommodate habitat heterogeneity, the study area was hierarchically stratified into different levels of spatial aggregation.
Below, we will provide a brief description of each of these strata, ranging from the ecoregion level to the specific sampling point level.
For a more comprehensive explanation of the reasoning behind each stratification, please refer to @Wilgenburg2020.

## Ecoregion

The ecoregion is the first level of aggregation in the sampling design.
The sample size and habitat inclusion probability (described in the next chapter) are defined for each separate ecoregion.
There are a total of `r length(ecor$ECOREGION)` ecoregions in the study area (@fig-ecoregion), and their details are described in @tbl-ecoregion.
Ecoregion 131 was excluded from the study area because it was too small to support enough sampling points for the random sampling design.

```{r tableEcoz,echo=FALSE,message=FALSE,warning=FALSE}
#| label: tbl-ecoregion
#| tbl-cap: Area (in hectares) and proportion of ecozones covered by the study area.

size_eco = st_area(ecor)
units(size_eco) = NULL
ecor |>
mutate(
    Code = ECOREGION,
    Name = REGION_NAM,
    Siz = size_eco
) |>
arrange(desc(Siz)) |>
mutate(
    `Area (% prop)` = paste0(
        round(Siz/10000, 0),
        ' (',
        round(Siz/sum(Siz) * 100, 2),
        ')'
    )
) |>
st_drop_geometry() |>
select(Code, Name, `Area (% prop)`) |>
kbl(format = 'markdown', align = 'c')
```

The sample size for this study was determined solely based on the size of the ecoregion.
While the BOSS design considered bird species richness to increase sampling in regions with more bird species, we chose not to use this metric because it may be biased by sampling efforts in the southern region, potentially increasing sampling bias in already well-covered regions.
Our goal was to sample 2% of the available hexagons (PSU described below) in each ecoregion.
We defined a hexagon as available for sampling if at least 20% of it contained natural habitat types.

```{r printEcoregion,echo=FALSE,message=FALSE,warning=FALSE,fig.width=8,fig.height=8}
#| label: fig-ecoregion
#| fig-cap: "Ecoregions (code) of the study area. Code description is detailed in @tbl-ecoregion."

ecor |>
    select(ECOREGION) |>
    ggplot() +
        geom_sf() +
        geom_sf_label(
            aes(label = ECOREGION),
            label.size = 0.1
        ) +
        coord_sf(crs = 4326) +
        theme_minimal() +
        theme(legend.position = 'none') +
        xlab('') + ylab('')
```

## Primary Sampling Unit (PSU)

We followed the BOSS design by using a 5 km diameter hexagon (@fig-PSUSSU) as the Primary Sampling Unit (PSU).
This was the lowest level of aggregation before performing the stratified sample with the GRTS algorithm.
We selected only the hexagons whose centroid fell within the study area.
Similarly, each hexagon was classified into one of the ecoregions using the same centroid rule.
The number of hexagons, available hexagones, and sample size is described in @tbl-sampleSize.

```{r tableSampleSize,echo=FALSE,message=FALSE,warning=FALSE}
#| label: tbl-sampleSize
#| tbl-cap: Distribution of total hexagons, hexagons with at least 20% of natural habitats, and sample size (2%) across the ecoregions.

hexas |>
    st_drop_geometry() |>
    filter(
        ecoregion %in% grep('N|S', ecoregion, invert = TRUE, value = TRUE)
    ) |>
    group_by(ecoregion) |>
    mutate(
        nbHex = n(),
        nbHex_fil = sum(propNA <= 0.8, na.rm = TRUE),
        sampleSize = round(nbHex_fil * 0.02, 0)
    ) |>
    filter(row_number() == 1) |>
    ungroup() |>
    left_join(
        ecor |>
            mutate(ecoregion = as.character(ECOREGION)) |>
            select(ecoregion, REGION_NAM)
    ) |>
    mutate(
        `Ecoregion code` = ecoregion,
        `Ecoregion name` = REGION_NAM,
        `Total Hexagons` = nbHex_fil,
        `Available Hexagons` = nbHex_fil,
        `Sample size` = sampleSize
    ) |>
    select(`Ecoregion code`, `Ecoregion name`, `Total Hexagons`, `Available Hexagons`, `Sample size`) |>
    kbl(format = 'markdown', align = 'c')
```

## Secondary Sampling Unit (SSU)

For each PSU hexagon, we created a grid of Secondary Sampling Units (SSUs).
The SSU represents the ultimate sampling locations to be utilized in the field.
Instead of using the proposed 300-meter distance from the BOSS design, we followed the approach used in the Ontario regionalization design, where each SSU was separated by 294 meters.
We made this small reduction in distance to ensure that the same number of SSUs were present across all PSU hexagons.
@fig-PSUSSU displays the distribution of Secondary Sampling Units (SSUs) within a hexagon.

```{r ssuExp,echo=FALSE,message=FALSE,warning=FALSE,fig.width=8,fig.height=8}
#| label: fig-PSUSSU
#| fig-cap: "Distribution of Secondary Sampling Units (SSUs) spaced 294 meters apart within an Primary Sampling Unit (PSU) hexagon."

# function to generate SSU points (from: https://github.com/dhope/BASSr)
genSSU <- function(h, spacing)
{
    ch <- as_tibble(st_coordinates(h))
    top_point <- ch[which.max(ch$Y),]
    bottom_point <- ch[which.min(ch$Y),]
    gridsize <- 2*floor(abs(top_point$Y-bottom_point$Y)/spacing)+3
    rowAngle <- tanh((top_point$X-bottom_point$X)/(top_point$Y-bottom_point$Y))

    cent <- st_centroid(h) %>%
        bind_cols(as_tibble(st_coordinates(.))) %>%
        st_drop_geometry %>%
        dplyr::select(ET_Index, X, Y)

    genRow <- function(cX, cY, sp,...){
        tibble(rowid = seq(-gridsize,gridsize)) %>%
        mutate(X = sin(60*pi/180+rowAngle) *sp*rowid + {{cX}},
                Y = cos(60*pi/180+rowAngle) *sp*rowid  + {{cY}})
    }

    centroids <- tibble(crowid=seq(-gridsize,gridsize)) %>%
        mutate(cY = cos(rowAngle) *spacing*crowid + cent$Y,
            #spacing/2*crowid + cent$Y,
            cX =  sin(rowAngle) *spacing*crowid + cent$X) %>%
        #cent$X + crowid* sqrt(spacing**2-(spacing/2)**2)) %>%
        rowwise() %>%
        mutate(row = list(genRow(cX = cX,cY = cY,sp = spacing))) %>%
        unnest(row) %>%
        dplyr::select(X,Y) %>%
        st_as_sf(coords = c("X", "Y"), crs = st_crs(h)) %>%
        st_filter(h) %>%
        mutate(
            ET_Index = h$ET_Index,
            ecoregion = h$ecoregion,
            ssuID = row_number()
        )
    return(centroids)
}

sel_hexas <- subset(hexas, propNA < 0.8)[1, ]
    
ggplot(sel_hexas) +
    geom_sf(aes()) +
    geom_sf(
        data = genSSU(sel_hexas, spacing = 294),
        alpha = .5
    ) +
    theme_minimal() +
    coord_sf(crs = 4326)
```
